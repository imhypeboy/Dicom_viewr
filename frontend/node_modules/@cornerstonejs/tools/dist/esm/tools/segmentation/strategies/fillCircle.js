import { vec3 } from 'gl-matrix';
import { utilities as csUtils } from '@cornerstonejs/core';
import { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';
import BrushStrategy from './BrushStrategy';
import { StrategyCallbacks } from '../../../enums';
import compositions from './compositions';
import { pointInSphere } from '../../../utilities/math/sphere';
const { transformWorldToIndex, isEqual } = csUtils;
export function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {
    const [bottom, top, left, right] = canvasCoordinates;
    const topLeft = [left[0], top[1]];
    const bottomRight = [right[0], bottom[1]];
    const bottomLeft = [left[0], bottom[1]];
    const topRight = [right[0], top[1]];
    return [topLeft, bottomRight, bottomLeft, topRight];
}
const initializeCircle = {
    [StrategyCallbacks.Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData, } = operationData;
        if (!points) {
            return;
        }
        const center = vec3.create();
        if (points.length >= 2) {
            vec3.add(center, points[0], points[1]);
            vec3.scale(center, center, 0.5);
        }
        else {
            vec3.copy(center, points[0]);
        }
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);
        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));
        const circleCornersIJK = points.map((world) => {
            return transformWorldToIndex(segmentationImageData, world);
        });
        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());
        operationData.isInObject = createPointInEllipse(cornersInWorld);
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInEllipse(cornersInWorld = []) {
    if (!cornersInWorld || cornersInWorld.length !== 4) {
        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');
    }
    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;
    const center = vec3.create();
    vec3.add(center, topLeft, bottomRight);
    vec3.scale(center, center, 0.5);
    const majorAxisVec = vec3.create();
    vec3.subtract(majorAxisVec, topRight, topLeft);
    const xRadius = vec3.length(majorAxisVec) / 2;
    vec3.normalize(majorAxisVec, majorAxisVec);
    const minorAxisVec = vec3.create();
    vec3.subtract(minorAxisVec, bottomLeft, topLeft);
    const yRadius = vec3.length(minorAxisVec) / 2;
    vec3.normalize(minorAxisVec, minorAxisVec);
    const normal = vec3.create();
    vec3.cross(normal, majorAxisVec, minorAxisVec);
    vec3.normalize(normal, normal);
    if (isEqual(xRadius, yRadius)) {
        const radius = xRadius;
        const sphereObj = {
            center,
            radius,
            radius2: radius * radius,
        };
        return (pointLPS) => pointInSphere(sphereObj, pointLPS);
    }
    return (pointLPS) => {
        const pointVec = vec3.create();
        vec3.subtract(pointVec, pointLPS, center);
        const distToPlane = vec3.dot(pointVec, normal);
        const proj = vec3.create();
        vec3.scaleAndAdd(proj, pointVec, normal, -distToPlane);
        const fromTopLeft = vec3.create();
        const centerToTopLeft = vec3.create();
        vec3.subtract(centerToTopLeft, center, topLeft);
        vec3.subtract(fromTopLeft, proj, centerToTopLeft);
        const x = vec3.dot(fromTopLeft, majorAxisVec);
        const y = vec3.dot(fromTopLeft, minorAxisVec);
        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;
    };
}
const CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);
const CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);
const fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
const thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
export function fillOutsideCircle() {
    throw new Error('Not yet implemented');
}
export { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse as createEllipseInPoint, };
