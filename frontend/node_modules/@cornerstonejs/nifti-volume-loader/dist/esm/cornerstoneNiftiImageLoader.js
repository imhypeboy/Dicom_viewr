import { Enums, eventTarget, metaData, triggerEvent, utilities, } from '@cornerstonejs/core';
import * as NiftiReader from 'nifti-reader-js';
import { Events } from './enums';
import { modalityScaleNifti } from './helpers';
import { getOptions } from './internal';
const dataFetchStateMap = new Map();
function fetchArrayBuffer({ url, signal, onload, }) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        const defaultHeaders = {};
        const options = getOptions();
        const beforeSendHeaders = options.beforeSend(xhr, defaultHeaders, url);
        const headers = Object.assign({}, defaultHeaders, beforeSendHeaders);
        xhr.responseType = 'arraybuffer';
        Object.keys(headers).forEach(function (key) {
            if (headers[key] === null) {
                return;
            }
            xhr.setRequestHeader(key, headers[key]);
        });
        const onLoadHandler = function (e) {
            if (onload && typeof onload === 'function') {
                onload();
            }
            if (signal) {
                signal.removeEventListener('abort', onAbortHandler);
            }
            resolve(xhr.response);
        };
        const onAbortHandler = () => {
            xhr.abort();
            xhr.removeEventListener('load', onLoadHandler);
            reject(new Error('Request aborted'));
        };
        xhr.addEventListener('load', onLoadHandler);
        const onProgress = (loaded, total) => {
            const data = { url, loaded, total };
            triggerEvent(eventTarget, Events.NIFTI_VOLUME_PROGRESS, { data });
        };
        xhr.onprogress = function (e) {
            onProgress(e.loaded, e.total);
        };
        if (signal && signal.aborted) {
            xhr.abort();
            reject(new Error('Request aborted'));
        }
        else if (signal) {
            signal.addEventListener('abort', onAbortHandler);
        }
        xhr.send();
    });
}
export default function cornerstoneNiftiImageLoader(imageId) {
    const [url, frame] = imageId.substring(6).split('?frame=');
    const sliceIndex = parseInt(frame, 10);
    const imagePixelModule = metaData.get(Enums.MetadataModules.IMAGE_PIXEL, imageId);
    const imagePlaneModule = metaData.get(Enums.MetadataModules.IMAGE_PLANE, imageId);
    const promise = new Promise((resolve, reject) => {
        if (!dataFetchStateMap.get(url)) {
            dataFetchStateMap.set(url, { status: 'fetching' });
            fetchAndProcessNiftiData(imageId, url, sliceIndex, imagePixelModule, imagePlaneModule)
                .then(resolve)
                .catch(reject);
        }
        else {
            waitForNiftiData(imageId, url, sliceIndex, imagePixelModule, imagePlaneModule)
                .then(resolve)
                .catch(reject);
        }
    });
    return {
        promise: promise,
        cancelFn: undefined,
        decache: () => {
            dataFetchStateMap.delete(url);
        },
    };
}
async function fetchAndProcessNiftiData(imageId, url, sliceIndex, imagePixelModule, imagePlaneModule) {
    let niftiBuffer = await fetchArrayBuffer({ url });
    let niftiHeader = null;
    let niftiImage = null;
    if (NiftiReader.isCompressed(niftiBuffer)) {
        niftiBuffer = NiftiReader.decompress(niftiBuffer);
    }
    if (NiftiReader.isNIFTI(niftiBuffer)) {
        niftiHeader = NiftiReader.readHeader(niftiBuffer);
        niftiImage = NiftiReader.readImage(niftiHeader, niftiBuffer);
    }
    else {
        const errorMessage = 'The provided buffer is not a valid NIFTI file.';
        console.warn(errorMessage);
        throw new Error(errorMessage);
    }
    const { scalarData } = modalityScaleNifti(niftiHeader, niftiImage);
    dataFetchStateMap.set(url, { status: 'fetched', scalarData });
    return createImage(imageId, sliceIndex, imagePixelModule, imagePlaneModule, scalarData);
}
function waitForNiftiData(imageId, url, sliceIndex, imagePixelModule, imagePlaneModule) {
    return new Promise((resolve) => {
        const intervalId = setInterval(() => {
            const dataFetchState = dataFetchStateMap.get(url);
            if (dataFetchState.status === 'fetched') {
                clearInterval(intervalId);
                resolve(createImage(imageId, sliceIndex, imagePixelModule, imagePlaneModule, dataFetchState.scalarData));
            }
        }, 10);
    });
}
function createImage(imageId, sliceIndex, imagePixelModule, imagePlaneModule, niftiScalarData) {
    const { rows, columns } = imagePlaneModule;
    const numVoxels = rows * columns;
    const sliceOffset = numVoxels * sliceIndex;
    const pixelData = new niftiScalarData.constructor(numVoxels);
    pixelData.set(niftiScalarData.subarray(sliceOffset, sliceOffset + numVoxels));
    const voxelManager = utilities.VoxelManager.createImageVoxelManager({
        width: columns,
        height: rows,
        numberOfComponents: 1,
        scalarData: pixelData,
    });
    let minPixelValue = pixelData[0];
    let maxPixelValue = pixelData[0];
    for (let i = 1; i < pixelData.length; i++) {
        const pixelValue = pixelData[i];
        if (pixelValue < minPixelValue) {
            minPixelValue = pixelValue;
        }
        if (pixelValue > maxPixelValue) {
            maxPixelValue = pixelValue;
        }
    }
    return {
        imageId,
        dataType: niftiScalarData.constructor
            .name,
        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,
        columns: imagePlaneModule.columns,
        height: imagePlaneModule.rows,
        invert: imagePixelModule.photometricInterpretation === 'MONOCHROME1',
        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,
        rows: imagePlaneModule.rows,
        sizeInBytes: rows * columns * niftiScalarData.BYTES_PER_ELEMENT,
        width: imagePlaneModule.columns,
        getPixelData: () => voxelManager.getScalarData(),
        getCanvas: undefined,
        numberOfComponents: undefined,
        voxelManager,
        minPixelValue,
        maxPixelValue,
    };
}
